<html>
<head>
<meta charset="utf-8">
<title>Water</title>
</head>
<script src="gl-matrix-min.js"></script>
<script src="shader.js"></script>
<script src="camera.js"></script>
<script src="cube.js"></script>
<script src="sphere.js"></script>

<script id="main"> 

var canvas;
var gl;
var lightPosition = vec3.fromValues(0.0, 5.0, 0.0);
var matrixStack = []; 

var moveMatrix = mat4.create();
var rotation = mat4.create();

var cubeMatrix = mat4.create();
var sphereMatrix = mat4.create();
var initSphereMatrix = mat4.create();

var cube;
var sphere;
 
var vs = vShader();  
var fs = fShader(); 
var program;    
var perspectiveMatrix;
var modelviewMatrix;

var vertexBuffer;
var normalBuffer;

var mouseDown = false;
var onTarget = false;
 
var startX = 0.0;
var startY = 0.0;
var camera = new Camera();   

function initProgram () {
    //compile shader
    vshader = gl.createShader(gl.VERTEX_SHADER);
    fshader = gl.createShader(gl.FRAGMENT_SHADER);
    
    gl.shaderSource(vshader, vs);
    gl.compileShader(vshader);
    
    gl.shaderSource(fshader, fs);
    gl.compileShader(fshader);

    program = gl.createProgram();
    gl.attachShader(program, vshader);
    gl.attachShader(program, fshader);
    gl.linkProgram(program);
    gl.useProgram(program);
} 

function initObjects() {
    cube = new Cube(40, 20);
    sphere = new Sphere(40, 20);
    program.nodesType = gl.getUniformLocation(program, "nodes[0].type");
    gl.uniform1i(program.nodesType, false, 0);   
   
    program.nodesType = gl.getUniformLocation(program, "nodes[1].type");
    gl.uniform1i(program.nodesType, false, 1);
}
 
function drawObj(obj, curMatrix) {

    vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(obj.vertices), gl.STATIC_DRAW);
    program.v = gl.getAttribLocation(program, 'aVertexPosition');
    gl.enableVertexAttribArray(program.v);
        

    program.tMatrixUniform = gl.getUniformLocation(program, "uTMatrix");
    gl.uniformMatrix4fv(program.tMatrixUniform, false, curMatrix);
         
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(program.v, 3, gl.FLOAT, false, 0, 0);
   
    gl.drawArrays(gl.TRIANGLES, 0, obj.vNum); 

}

function updateMatrix () {
    program.pMatrixUniform = gl.getUniformLocation(program, "uPMatrix");
    gl.uniformMatrix4fv(program.pMatrixUniform, false, camera.getPMatrix());

    program.mvMatrixUniform = gl.getUniformLocation(program, "uMVMatrix");
    gl.uniformMatrix4fv(program.mvMatrixUniform, false, camera.getMVMatrix());
    
    cubeMatrix = rotation;
    mat4.multiply(sphereMatrix, rotation, moveMatrix);
    mat4.multiply(sphereMatrix, sphereMatrix, initSphereMatrix);
    
  
    program.nodesMatrix = gl.getUniformLocation(program, "nodes[0].mMatrix");
    gl.uniformMatrix4fv(program.nodesMatrix, false, cubeMatrix);   
   
    program.nodesMatrix = gl.getUniformLocation(program, "nodes[1].mMatrix");
    gl.uniformMatrix4fv(program.nodesMatrix, false, sphereMatrix);       
        
}

function drawMyScene () {

            
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);
        
        program.nodeCount = gl.getUniformLocation(program, "nodeCount");
        gl.uniform1i(program.nodeCount, false, 2);
        
        updateMatrix();
 
        //draw cube
        drawObj(cube, cubeMatrix);
        
        //draw sphere
        drawObj(sphere, sphereMatrix);
 
       
}

function initWebgl() {
    canvas = document.getElementById('water');
    gl = canvas.getContext('webgl');
    gl.viewportWidth = canvas.clientWidth;
	gl.viewportHeight = canvas.clientHeight;
}
function main() {


    initWebgl();
    initProgram();
    //initialize light
    program.lightCount = gl.getUniformLocation(program, "lightCount");
    gl.uniform1i(program.lightCount, false, 1); 
    program.lightPosition = gl.getUniformLocation(program, "lightPosition");
    gl.uniformMatrix4fv(program.lightPosition, false, lightPosition);
    
    initObjects();
       
    mat4.translate(initSphereMatrix, initSphereMatrix, [0.5, -0.25, 0.0]);
    mat4.scale(initSphereMatrix, initSphereMatrix, [0.5, 0.5, 0.5]);
    
    drawMyScene();    
}

function myMouseDown(mouseEvent) {
 
    startX = (mouseEvent.clientX * 2 - gl.viewportWidth)/gl.viewportWidth;
    startY = (gl.viewportHeight - mouseEvent.clientY * 2)/gl.viewportHeight;
    mouseDown = true;
    var eye = camera.getEye();
    var near = camera.getNear();
    var point = quat.fromValues(startX, startY, -1.0, 1.0);
    quat.scale(point, point, near);
    
    var MVinverse = mat4.create();
    mat4.multiply(MVinverse, camera.getPMatrix(), camera.getMVMatrix());
    mat4.invert(MVinverse, MVinverse);
    mat4.multiply(point, MVinverse, point);
 
    var n = vec4.fromValues(point[0] - eye[0],
                            point[1] - eye[1],
                            point[2] - eye[2],
                                            0);
    
    vec4.normalize(n, n);
        
    mat4.invert(MVinverse, sphereMatrix);
    mat4.multiply(n, MVinverse, n);
    mat4.multiply(point, MVinverse, point);
  
    var a = n[0] * n[0] + n[1] * n[1] + n[2] * n[2];
    var b = 2 * (point[0] * n[0] + point[1] * n[1] + point[2] * n[2]);
    var c = point[0] * point[0] + point[1] * point[1] + point[2] * point[2] - 0.25;
 
    if ((b * b) > (4 * a * c)) {
        onTarget = true;
    }
}

function myMouseMove(mouseEvent) {
    var curX = (mouseEvent.clientX * 2 - gl.viewportWidth)/gl.viewportWidth;
    var curY = (gl.viewportHeight - mouseEvent.clientY * 2)/gl.viewportHeight;

    if (mouseDown && onTarget) {
        var eye = camera.getEye();
        var focus = camera.getFocus();
        var v1 = vec3.fromValues(eye[0] - focus[0], 
                                 eye[1] - focus[1], 
                                 eye[2] - focus[2]);

        var vtmp = vec4.fromValues(curY -startY, startX - curX, 0, 0.0);
        var MVinverse = mat4.create();
        mat4.multiply(MVinverse, camera.getPMatrix(), camera.getMVMatrix());
        mat4.invert(MVinverse, MVinverse);
        mat4.multiply(vtmp, MVinverse, vtmp); 
        var v2 = vec3.fromValues(vtmp[0], vtmp[1], vtmp[2]);
         
        var moveVector = vec3.fromValues(v1[1] * v2[2] - v2[1] * v1[2], 
                                         v1[2] * v2[0] - v2[2] * v1[0],
                                         v1[0] * v2[1] - v2[0] * v1[1]); 
        mat4.invert(MVinverse, rotation);
        var moveTmp = vec4.fromValues(moveVector[0], moveVector[1], moveVector[2], 0);
        mat4.multiply(moveTmp, MVinverse, moveTmp);
        moveVector = vec3.fromValues(moveTmp[0], moveTmp[1], moveTmp[2]);           
        vec3.normalize(moveVector, moveVector);
        var mag = Math.sqrt( (curX - startX) * (curX - startX)
                  + (curY - startY) * (curY - startY));
       
        vec3.scale(moveVector, moveVector, mag);
         
        mat4.translate(moveMatrix, moveMatrix, moveVector);
               
        drawMyScene();
    
    } else if (mouseDown) {
        
        var v2 = vec4.fromValues(curX - startX, curY - startY, 0.0, 0.0);   
        var MVinverse = mat4.create();
        
        mat4.multiply(MVinverse, camera.getPMatrix(), camera.getMVMatrix());
        mat4.invert(MVinverse, MVinverse);
 
        mat4.multiply(v2, MVinverse, v2);
        var eye = camera.getEye();
        var focus = camera.getFocus();     
        var v1 = vec3. fromValues(eye[0] - focus[0], 
                                  eye[1] - focus[1], 
                                  eye[2] - focus[2]);

        var rad = Math.sqrt((startX - curX) * (startX - curX) 
                         + (startY - curY) * (startY - curY));
        var axis = vec3.fromValues(v1[1] * v2[2] - v2[1] * v1[2], 
                                       v1[2] * v2[0] - v2[2] * v1[0],
                                       v1[0] * v2[1] - v2[0] * v1[1]);  
  
        vec3.normalize(axis, axis);
        var tmp = mat4.create();  
        mat4.rotate(tmp, tmp, rad, axis);
        mat4.multiply(rotation, tmp, rotation);
        
        drawMyScene();
    }

    startX = curX;
    startY = curY;         

}
function myMouseUp(mouseEvent) {
    mouseDown = false;
    onTarget = false;
 
}
function myMouseOut(mouseEvent) {
    mouseDown = false;
    onTarget = false;
}


</script>
<body onload="main();">
<canvas id="water" width="500" height="500" onmousedown="myMouseDown(event)"    
        onmousemove="myMouseMove(event)" onmouseup="myMouseUp(event)" 
        onmouseout="myMouseOut(event)">
Earth in Water
</canvas>

</body>

</html>
